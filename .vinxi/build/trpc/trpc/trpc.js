import{defineEventHandler as R,toWebRequest as _}from"@tanstack/react-start/server";import{fetchRequestHandler as j}from"@trpc/server/adapters/fetch";import{initTRPC as L,TRPCError as a}from"@trpc/server";import V from"superjson";import{ZodError as $,z as t}from"zod";import{PrismaClient as Q}from"@prisma/client";import z from"dotenv";import q from"jsonwebtoken";import k from"bcryptjs";import{randomBytes as U}from"crypto";const P=L.create({transformer:V,sse:{enabled:!0,client:{reconnectAfterInactivityMs:5e3},ping:{enabled:!0,intervalMs:2500}},errorFormatter({shape:e,error:s}){return{...e,data:{...e.data,zodError:s.cause instanceof $?s.cause.flatten():null}}}}),H=P.createCallerFactory,G=P.router,i=P.procedure;z.config();const W=t.object({NODE_ENV:t.enum(["development","production"]),BASE_URL:t.string().optional(),BASE_URL_OTHER_PORT:t.string().optional(),ADMIN_PASSWORD:t.string(),JWT_SECRET:t.string()}),C=W.parse(process.env),K=()=>new Q({log:C.NODE_ENV==="development"?["query","error","warn"]:["error"]}),M=globalThis,r=M.prisma??K();C.NODE_ENV!=="production"&&(M.prisma=r);const x=e=>q.sign(e,C.JWT_SECRET,{expiresIn:"1y"}),J=e=>{try{const s=q.verify(e,C.JWT_SECRET);return t.object({userId:t.number(),role:t.string(),memberId:t.number().optional()}).parse(s)}catch{throw new a({code:"UNAUTHORIZED",message:"Invalid or expired token"})}},A=async e=>await k.hash(e,12),Z=async(e,s)=>await k.compare(e,s),S=async e=>{const s=J(e),n=await r.user.findUnique({where:{id:s.userId},include:{member:!0}});if(!n)throw new a({code:"UNAUTHORIZED",message:"User not found"});return{user:n,payload:s}},w=async e=>{const{user:s,payload:n}=await S(e);if(s.role!=="ADMIN")throw new a({code:"FORBIDDEN",message:"Admin access required"});return{user:s,payload:n}},B=async e=>{const{user:s,payload:n}=await S(e);if(s.role!=="MEMBER"&&s.role!=="ADMIN")throw new a({code:"FORBIDDEN",message:"Member access required"});return{user:s,payload:n}},X=i.input(t.object({email:t.string().email(),password:t.string().min(1)})).mutation(async({input:e})=>{const s=await r.user.findUnique({where:{email:e.email},include:{member:!0}});if(!s)throw new a({code:"UNAUTHORIZED",message:"Invalid email or password"});if(!await Z(e.password,s.password))throw new a({code:"UNAUTHORIZED",message:"Invalid email or password"});return{token:x({userId:s.id,role:s.role,memberId:s.memberId||void 0}),user:{id:s.id,email:s.email,role:s.role,member:s.member}}}),Y=i.input(t.object({memberName:t.string().min(1),memberEmail:t.string().email(),memberPhone:t.string().optional(),adults:t.number().min(1).default(1),children:t.number().min(0).default(0),infants:t.number().min(0).default(0),elder:t.number().min(0).default(0),password:t.string().min(6)})).mutation(async({input:e})=>{if(await r.user.findUnique({where:{email:e.memberEmail}}))throw new a({code:"CONFLICT",message:"User with this email already exists"});if(await r.member.findUnique({where:{memberEmail:e.memberEmail}}))throw new a({code:"CONFLICT",message:"Member with this email already exists"});const d=await A(e.password),u=await r.member.create({data:{memberName:e.memberName,memberEmail:e.memberEmail,memberPhone:e.memberPhone,adults:e.adults,children:e.children,infants:e.infants,elder:e.elder}}),p=await r.user.create({data:{email:e.memberEmail,password:d,role:"MEMBER",memberId:u.id}});return{token:x({userId:p.id,role:p.role,memberId:u.id}),user:{id:p.id,email:p.email,role:p.role,member:u}}}),ee=i.input(t.object({authToken:t.string()})).query(async({input:e})=>{const{user:s}=await S(e.authToken);return{id:s.id,email:s.email,role:s.role,member:s.member}}),te=i.input(t.object({authToken:t.string(),memberName:t.string().min(1),memberEmail:t.string().email(),memberPhone:t.string().optional(),adults:t.number().min(1),children:t.number().min(0),infants:t.number().min(0),elder:t.number().min(0),password:t.string().min(6),role:t.enum(["ADMIN","MEMBER"])})).mutation(async({input:e})=>{if(await w(e.authToken),await r.user.findUnique({where:{email:e.memberEmail}}))throw new a({code:"CONFLICT",message:"User with this email already exists"});if(await r.member.findUnique({where:{memberEmail:e.memberEmail}}))throw new a({code:"CONFLICT",message:"Member with this email already exists"});const d=await A(e.password),u=await r.member.create({data:{memberName:e.memberName,memberEmail:e.memberEmail,memberPhone:e.memberPhone,adults:e.adults,children:e.children,infants:e.infants,elder:e.elder}}),p=await r.user.create({data:{email:e.memberEmail,password:d,role:e.role,memberId:u.id}});return{success:!0,user:{id:p.id,email:p.email,role:p.role,member:u}}}),se=i.input(t.object({authToken:t.string()})).query(async({input:e})=>(await w(e.authToken),(await r.user.findMany({include:{member:!0},orderBy:{createdAt:"desc"}})).map(n=>({id:n.id,email:n.email,role:n.role,createdAt:n.createdAt,member:n.member})))),re=i.input(t.object({authToken:t.string(),userId:t.number(),memberName:t.string().min(1).optional(),memberEmail:t.string().email().optional(),memberPhone:t.string().optional(),adults:t.number().min(1).optional(),children:t.number().min(0).optional(),infants:t.number().min(0).optional(),elder:t.number().min(0).optional(),password:t.string().min(6).optional(),role:t.enum(["ADMIN","MEMBER"]).optional()})).mutation(async({input:e})=>{await w(e.authToken);const s=await r.user.findUnique({where:{id:e.userId},include:{member:!0}});if(!s)throw new a({code:"NOT_FOUND",message:"User not found"});if(e.memberEmail&&e.memberEmail!==s.email&&await r.user.findUnique({where:{email:e.memberEmail}}))throw new a({code:"CONFLICT",message:"User with this email already exists"});s.member&&(e.memberName||e.memberEmail||e.memberPhone!==void 0||e.adults!==void 0||e.children!==void 0||e.infants!==void 0||e.elder!==void 0)&&await r.member.update({where:{id:s.member.id},data:{...e.memberName&&{memberName:e.memberName},...e.memberEmail&&{memberEmail:e.memberEmail},...e.memberPhone!==void 0&&{memberPhone:e.memberPhone},...e.adults!==void 0&&{adults:e.adults},...e.children!==void 0&&{children:e.children},...e.infants!==void 0&&{infants:e.infants},...e.elder!==void 0&&{elder:e.elder}}});const n={};e.memberEmail&&(n.email=e.memberEmail),e.role&&(n.role=e.role),e.password&&(n.password=await A(e.password));const d=await r.user.update({where:{id:e.userId},data:n,include:{member:!0}});return{success:!0,user:{id:d.id,email:d.email,role:d.role,member:d.member}}}),oe=i.input(t.object({authToken:t.string(),userId:t.number()})).mutation(async({input:e})=>{if(await w(e.authToken),!await r.user.findUnique({where:{id:e.userId}}))throw new a({code:"NOT_FOUND",message:"User not found"});return await r.user.delete({where:{id:e.userId}}),{success:!0}}),ne=i.input(t.object({authToken:t.string(),venueAddress:t.string().min(1),venueCapacity:t.number().min(1),venueDetails:t.string().optional()})).mutation(async({input:e})=>(await w(e.authToken),{success:!0,venue:await r.venue.create({data:{venueAddress:e.venueAddress,venueCapacity:e.venueCapacity,venueDetails:e.venueDetails}})})),ae=i.input(t.object({authToken:t.string()})).query(async({input:e})=>(await S(e.authToken),await r.venue.findMany({include:{events:{select:{id:!0,eventName:!0,startDate:!0,endDate:!0}}},orderBy:{createdAt:"desc"}}))),de=i.input(t.object({authToken:t.string(),venueId:t.number(),venueAddress:t.string().min(1).optional(),venueCapacity:t.number().min(1).optional(),venueDetails:t.string().optional()})).mutation(async({input:e})=>{if(await w(e.authToken),!await r.venue.findUnique({where:{id:e.venueId}}))throw new a({code:"NOT_FOUND",message:"Venue not found"});return{success:!0,venue:await r.venue.update({where:{id:e.venueId},data:{...e.venueAddress&&{venueAddress:e.venueAddress},...e.venueCapacity&&{venueCapacity:e.venueCapacity},...e.venueDetails!==void 0&&{venueDetails:e.venueDetails}}})}}),ie=i.input(t.object({authToken:t.string(),venueId:t.number()})).mutation(async({input:e})=>{await w(e.authToken);const s=await r.venue.findUnique({where:{id:e.venueId},include:{events:!0}});if(!s)throw new a({code:"NOT_FOUND",message:"Venue not found"});if(s.events.length>0)throw new a({code:"BAD_REQUEST",message:"Cannot delete venue with existing events"});return await r.venue.delete({where:{id:e.venueId}}),{success:!0}}),ce=i.input(t.object({authToken:t.string(),eventName:t.string().min(1),startDate:t.string().date(),endDate:t.string().date(),eventDetails:t.string().optional(),venueId:t.number()})).mutation(async({input:e})=>{if(await w(e.authToken),!await r.venue.findUnique({where:{id:e.venueId}}))throw new a({code:"NOT_FOUND",message:"Venue not found"});const n=new Date(e.startDate),d=new Date(e.endDate);if(n>d)throw new a({code:"BAD_REQUEST",message:"End date must be on or after start date"});return{success:!0,event:await r.event.create({data:{eventName:e.eventName,startDate:n,endDate:d,eventDetails:e.eventDetails,venueId:e.venueId},include:{venue:!0}})}}),ue=i.input(t.object({authToken:t.string()})).query(async({input:e})=>(await S(e.authToken),await r.event.findMany({include:{venue:!0,sessions:{orderBy:{sessionDate:"asc"}},expenses:{select:{id:!0,amount:!0,status:!0}}},orderBy:{startDate:"desc"}}))),me=i.input(t.object({authToken:t.string(),eventId:t.number(),eventName:t.string().min(1).optional(),startDate:t.string().date().optional(),endDate:t.string().date().optional(),eventDetails:t.string().optional(),venueId:t.number().optional()})).mutation(async({input:e})=>{await w(e.authToken);const s=await r.event.findUnique({where:{id:e.eventId}});if(!s)throw new a({code:"NOT_FOUND",message:"Event not found"});if(e.venueId&&!await r.venue.findUnique({where:{id:e.venueId}}))throw new a({code:"NOT_FOUND",message:"Venue not found"});const n=e.startDate?new Date(e.startDate):s.startDate,d=e.endDate?new Date(e.endDate):s.endDate;if(n>d)throw new a({code:"BAD_REQUEST",message:"End date must be on or after start date"});return{success:!0,event:await r.event.update({where:{id:e.eventId},data:{...e.eventName&&{eventName:e.eventName},...e.startDate&&{startDate:new Date(e.startDate)},...e.endDate&&{endDate:new Date(e.endDate)},...e.eventDetails!==void 0&&{eventDetails:e.eventDetails},...e.venueId&&{venueId:e.venueId}},include:{venue:!0,sessions:!0}})}}),le=i.input(t.object({authToken:t.string(),eventId:t.number()})).mutation(async({input:e})=>{await w(e.authToken);const s=await r.event.findUnique({where:{id:e.eventId},include:{sessions:{include:{productSessionMaps:!0}},expenses:!0}});if(!s)throw new a({code:"NOT_FOUND",message:"Event not found"});if(await r.orderMaster.count({where:{orderLines:{some:{sessionId:{in:s.sessions.map(d=>d.id)}}}}})>0)throw new a({code:"BAD_REQUEST",message:"Cannot delete event with existing registrations"});return await r.event.delete({where:{id:e.eventId}}),{success:!0}}),pe=i.input(t.object({authToken:t.string(),sessionName:t.string().min(1),sessionDate:t.string().datetime(),startTime:t.string(),endTime:t.string(),sessionDetails:t.string().optional(),sessionBalanceCapacity:t.number().min(1),eventId:t.number()})).mutation(async({input:e})=>{await w(e.authToken);const s=await r.event.findUnique({where:{id:e.eventId}});if(!s)throw new a({code:"NOT_FOUND",message:"Event not found"});const n=new Date(e.sessionDate);if(n<s.startDate||n>s.endDate)throw new a({code:"BAD_REQUEST",message:"Session date must be within event date range"});return{success:!0,session:await r.eventSession.create({data:{sessionName:e.sessionName,sessionDate:n,startTime:e.startTime,endTime:e.endTime,sessionDetails:e.sessionDetails,sessionBalanceCapacity:e.sessionBalanceCapacity,eventId:e.eventId},include:{event:!0}})}}),we=i.input(t.object({authToken:t.string(),eventId:t.number().optional()})).query(async({input:e})=>{await S(e.authToken);const s=await r.eventSession.findMany({where:e.eventId?{eventId:e.eventId}:void 0,include:{event:{select:{id:!0,eventName:!0,startDate:!0,endDate:!0}},productSessionMaps:{include:{product:!0}}},orderBy:[{sessionDate:"asc"},{startTime:"asc"}]});return await Promise.all(s.map(async d=>{const u=await r.orderLine.count({where:{sessionId:d.id,product:{productType:"Entry"}}}),p=d.sessionBalanceCapacity-u,b=p<=0;return{...d,currentRegistrations:u,availableSpots:p,isFull:b}}))}),ye=i.input(t.object({authToken:t.string(),sessionId:t.number(),sessionName:t.string().min(1).optional(),sessionDate:t.string().datetime().optional(),startTime:t.string().optional(),endTime:t.string().optional(),sessionDetails:t.string().optional(),sessionBalanceCapacity:t.number().min(1).optional()})).mutation(async({input:e})=>{await w(e.authToken);const s=await r.eventSession.findUnique({where:{id:e.sessionId},include:{event:!0}});if(!s)throw new a({code:"NOT_FOUND",message:"Session not found"});if(e.sessionDate){const d=new Date(e.sessionDate);if(d<s.event.startDate||d>s.event.endDate)throw new a({code:"BAD_REQUEST",message:"Session date must be within event date range"})}return{success:!0,session:await r.eventSession.update({where:{id:e.sessionId},data:{...e.sessionName&&{sessionName:e.sessionName},...e.sessionDate&&{sessionDate:new Date(e.sessionDate)},...e.startTime&&{startTime:e.startTime},...e.endTime&&{endTime:e.endTime},...e.sessionDetails!==void 0&&{sessionDetails:e.sessionDetails},...e.sessionBalanceCapacity&&{sessionBalanceCapacity:e.sessionBalanceCapacity}},include:{event:!0,productSessionMaps:{include:{product:!0}}}})}}),he=i.input(t.object({authToken:t.string(),sessionId:t.number()})).mutation(async({input:e})=>{if(await w(e.authToken),!await r.eventSession.findUnique({where:{id:e.sessionId}}))throw new a({code:"NOT_FOUND",message:"Session not found"});if(await r.orderLine.count({where:{sessionId:e.sessionId}})>0)throw new a({code:"BAD_REQUEST",message:"Cannot delete session with existing registrations"});return await r.eventSession.delete({where:{id:e.sessionId}}),{success:!0}}),Te=i.input(t.object({authToken:t.string(),productCode:t.string().min(1),productName:t.string().min(1),productDesc:t.string().optional(),productType:t.enum(["Food","Entry"]),productTypes:t.array(t.object({productSize:t.enum(["Adult","Children","Elder"]),productChoice:t.enum(["VEG","NON-VEG","NONE"]),productPref:t.enum(["CHICKEN","MUTTON","FISH","NONE"]),productPrice:t.number().min(0),productSubtype:t.enum(["PACKET","DINE-IN","NONE"])})).optional()})).mutation(async({input:e})=>{if(await w(e.authToken),await r.product.findUnique({where:{productCode:e.productCode}}))throw new a({code:"CONFLICT",message:"Product with this code already exists"});return{success:!0,product:await r.product.create({data:{productCode:e.productCode,productName:e.productName,productDesc:e.productDesc,productType:e.productType,...e.productTypes&&e.productTypes.length>0&&{productTypes:{create:e.productTypes}}},include:{productTypes:!0}})}}),fe=i.input(t.object({authToken:t.string()})).query(async({input:e})=>(await S(e.authToken),await r.product.findMany({include:{productTypes:{where:{status:"ACTIVE"},orderBy:{productPrice:"asc"}},productSessionMaps:{include:{session:{select:{id:!0,sessionName:!0,sessionDate:!0}}}}},orderBy:{createdAt:"desc"}}))),be=i.input(t.object({authToken:t.string(),productId:t.number(),productCode:t.string().min(1).optional(),productName:t.string().min(1).optional(),productDesc:t.string().optional(),productType:t.enum(["Food","Entry"]).optional(),status:t.enum(["ACTIVE","INACTIVE"]).optional()})).mutation(async({input:e})=>{await w(e.authToken);const s=await r.product.findUnique({where:{id:e.productId}});if(!s)throw new a({code:"NOT_FOUND",message:"Product not found"});if(e.productCode&&e.productCode!==s.productCode&&await r.product.findUnique({where:{productCode:e.productCode}}))throw new a({code:"CONFLICT",message:"Product with this code already exists"});return{success:!0,product:await r.product.update({where:{id:e.productId},data:{...e.productCode&&{productCode:e.productCode},...e.productName&&{productName:e.productName},...e.productDesc!==void 0&&{productDesc:e.productDesc},...e.productType&&{productType:e.productType},...e.status&&{status:e.status}},include:{productTypes:!0}})}}),ge=i.input(t.object({authToken:t.string(),productId:t.number()})).mutation(async({input:e})=>{if(await w(e.authToken),!await r.product.findUnique({where:{id:e.productId}}))throw new a({code:"NOT_FOUND",message:"Product not found"});if(await r.orderLine.count({where:{productId:e.productId}})>0)throw new a({code:"BAD_REQUEST",message:"Cannot delete product with existing orders"});return await r.product.delete({where:{id:e.productId}}),{success:!0}}),Ie=i.input(t.object({authToken:t.string(),productId:t.number(),productSize:t.enum(["Adult","Children","Elder"]),productChoice:t.enum(["VEG","NON-VEG","NONE"]),productPref:t.enum(["CHICKEN","MUTTON","FISH","NONE"]),productPrice:t.number().min(0),productSubtype:t.enum(["PACKET","DINE-IN","NONE"])})).mutation(async({input:e})=>{if(await w(e.authToken),!await r.product.findUnique({where:{id:e.productId}}))throw new a({code:"NOT_FOUND",message:"Product not found"});return{success:!0,productType:await r.productType.create({data:{productId:e.productId,productSize:e.productSize,productChoice:e.productChoice,productPref:e.productPref,productPrice:e.productPrice,productSubtype:e.productSubtype}})}}),ve=i.input(t.object({authToken:t.string(),productTypeId:t.number(),productSize:t.enum(["Adult","Children","Elder"]).optional(),productChoice:t.enum(["VEG","NON-VEG","NONE"]).optional(),productPref:t.enum(["CHICKEN","MUTTON","FISH","NONE"]).optional(),productPrice:t.number().min(0).optional(),productSubtype:t.enum(["PACKET","DINE-IN","NONE"]).optional(),status:t.enum(["ACTIVE","INACTIVE"]).optional()})).mutation(async({input:e})=>{if(await w(e.authToken),!await r.productType.findUnique({where:{id:e.productTypeId}}))throw new a({code:"NOT_FOUND",message:"Product type not found"});const n={};return e.productSize!==void 0&&(n.productSize=e.productSize),e.productChoice!==void 0&&(n.productChoice=e.productChoice),e.productPref!==void 0&&(n.productPref=e.productPref),e.productPrice!==void 0&&(n.productPrice=e.productPrice),e.productSubtype!==void 0&&(n.productSubtype=e.productSubtype),e.status!==void 0&&(n.status=e.status),{success:!0,productType:await r.productType.update({where:{id:e.productTypeId},data:n})}}),Ne=i.input(t.object({authToken:t.string(),productTypeId:t.number()})).mutation(async({input:e})=>{if(await w(e.authToken),!await r.productType.findUnique({where:{id:e.productTypeId}}))throw new a({code:"NOT_FOUND",message:"Product type not found"});if(await r.orderLine.count({where:{productTypeId:e.productTypeId}})>0)throw new a({code:"BAD_REQUEST",message:"Cannot delete product type with existing orders"});return await r.productType.delete({where:{id:e.productTypeId}}),{success:!0}}),Ee=i.input(t.object({authToken:t.string(),productId:t.number(),sessionId:t.number()})).mutation(async({input:e})=>{if(await w(e.authToken),!await r.product.findUnique({where:{id:e.productId}}))throw new a({code:"NOT_FOUND",message:"Product not found"});if(!await r.eventSession.findUnique({where:{id:e.sessionId}}))throw new a({code:"NOT_FOUND",message:"Session not found"});if(await r.productSessionMap.findUnique({where:{sessionId_productId:{sessionId:e.sessionId,productId:e.productId}}}))throw new a({code:"CONFLICT",message:"Product is already tagged to this session"});return await r.productSessionMap.create({data:{productId:e.productId,sessionId:e.sessionId},include:{product:!0,session:{select:{id:!0,sessionName:!0,sessionDate:!0}}}})}),De=i.input(t.object({authToken:t.string(),productId:t.number(),sessionId:t.number()})).mutation(async({input:e})=>{await w(e.authToken);const s=await r.productSessionMap.findUnique({where:{sessionId_productId:{sessionId:e.sessionId,productId:e.productId}}});if(!s)throw new a({code:"NOT_FOUND",message:"Product is not tagged to this session"});return await r.productSessionMap.delete({where:{id:s.id}}),{success:!0}}),Se=i.input(t.object({authToken:t.string(),expenseType:t.string().min(1),vendor:t.string().min(1),amount:t.number().min(0),receiptFile:t.string().optional(),eventId:t.number()})).mutation(async({input:e})=>{const{user:s}=await B(e.authToken);if(!s.memberId)throw new a({code:"BAD_REQUEST",message:"User must be associated with a member"});if(!await r.event.findUnique({where:{id:e.eventId}}))throw new a({code:"NOT_FOUND",message:"Event not found"});return{success:!0,expense:await r.expense.create({data:{expenseType:e.expenseType,vendor:e.vendor,amount:e.amount,receiptFile:e.receiptFile,incurredBy:s.memberId,eventId:e.eventId},include:{member:{select:{id:!0,memberName:!0,memberEmail:!0}},event:{select:{id:!0,eventName:!0}}}})}}),Ce=i.input(t.object({authToken:t.string(),eventId:t.number().optional(),status:t.enum(["PENDING","APPROVED","REJECTED"]).optional()})).query(async({input:e})=>{const{user:s}=await S(e.authToken),n={};return s.role!=="ADMIN"&&(n.incurredBy=s.memberId),e.eventId&&(n.eventId=e.eventId),e.status&&(n.status=e.status),await r.expense.findMany({where:n,include:{member:{select:{id:!0,memberName:!0,memberEmail:!0}},event:{select:{id:!0,eventName:!0,startDate:!0,endDate:!0}}},orderBy:{createdAt:"desc"}})}),Oe=i.input(t.object({authToken:t.string(),expenseId:t.number(),status:t.enum(["APPROVED","REJECTED"])})).mutation(async({input:e})=>{if(await w(e.authToken),!await r.expense.findUnique({where:{id:e.expenseId}}))throw new a({code:"NOT_FOUND",message:"Expense not found"});return{success:!0,expense:await r.expense.update({where:{id:e.expenseId},data:{status:e.status},include:{member:{select:{id:!0,memberName:!0,memberEmail:!0}},event:{select:{id:!0,eventName:!0}}}})}}),Ue=i.input(t.object({authToken:t.string()})).query(async({input:e})=>(await w(e.authToken),await r.orderMaster.findMany({include:{guest:!0,member:!0,orderLines:{include:{product:!0,productType:!0}}},orderBy:{createdAt:"desc"}}))),Pe=i.input(t.object({authToken:t.string(),orderId:t.number(),totalCost:t.number().optional(),status:t.enum(["PENDING","CONFIRMED","CANCELLED","COMPLETED","REFUNDED"]).optional(),orderLines:t.array(t.object({productId:t.number(),productTypeId:t.number().optional(),quantity:t.number().min(0),sessionId:t.number().optional()})).optional()})).mutation(async({input:e})=>{await w(e.authToken);const{orderId:s,totalCost:n,status:d,orderLines:u,...p}=e;return u?await r.$transaction(async v=>{await v.orderLine.deleteMany({where:{orderId:s}}),u.length>0&&await v.orderLine.createMany({data:u.map(g=>({orderId:s,productId:g.productId,productTypeId:g.productTypeId,quantity:g.quantity,sessionId:g.sessionId}))});let N=n;if(N===void 0&&u.length>0){const g=u.filter(E=>E.productTypeId&&E.quantity>0).map(E=>E.productTypeId);if(g.length>0){const E=await v.productType.findMany({where:{id:{in:g}}});N=u.reduce((l,o)=>{if(o.productTypeId&&o.quantity>0){const y=E.find(f=>f.id===o.productTypeId);if(y)return l+y.productPrice*o.quantity}return l},0)}else N=0}return await v.orderMaster.update({where:{id:s},data:{...N!==void 0&&{totalCost:N},...d!==void 0&&{status:d}},include:{guest:!0,member:!0,orderLines:{include:{product:!0,productType:!0}}}})}):await r.orderMaster.update({where:{id:s},data:{...n!==void 0&&{totalCost:n},...d!==void 0&&{status:d}},include:{guest:!0,member:!0,orderLines:{include:{product:!0,productType:!0}}}})}),Ae=i.input(t.object({authToken:t.string(),orderId:t.number()})).mutation(async({input:e})=>(await w(e.authToken),await r.orderLine.deleteMany({where:{orderId:e.orderId}}),await r.orderMaster.delete({where:{id:e.orderId}}))),qe=i.input(t.object({guestName:t.string().min(1),guestEmail:t.string().email().optional(),guestPhone:t.string().optional(),guestLocation:t.string().optional(),adults:t.number().min(1),children:t.number().min(0),infants:t.number().min(0),elder:t.number().min(0),memberId:t.number(),eventId:t.number(),sessionSelections:t.array(t.object({sessionId:t.number(),optOutOfFood:t.boolean().default(!1),productSelections:t.array(t.object({productId:t.number(),productTypeId:t.number(),quantity:t.number().min(1)}))}))})).mutation(async({input:e})=>{if(!await r.member.findUnique({where:{id:e.memberId}}))throw new a({code:"NOT_FOUND",message:"Member not found"});const n=await r.event.findUnique({where:{id:e.eventId},include:{sessions:!0}});if(!n)throw new a({code:"NOT_FOUND",message:"Event not found"});const d=e.sessionSelections.map(c=>c.sessionId),u=n.sessions.map(c=>c.id);if(d.filter(c=>!u.includes(c)).length>0)throw new a({code:"BAD_REQUEST",message:"Invalid session selection"});for(const c of e.sessionSelections)if(c.optOutOfFood){for(const m of c.productSelections)if((await r.productType.findUnique({where:{id:m.productTypeId},include:{product:!0}}))?.product.productType==="Food")throw new a({code:"BAD_REQUEST",message:"Cannot select food products when opted out of food for a session"})}else{const m={};for(const I of c.productSelections){const h=await r.productType.findUnique({where:{id:I.productTypeId},include:{product:!0}});if(!h)throw new a({code:"NOT_FOUND",message:"Product type not found"});if(h.product.productType==="Food"&&h.productSubtype==="DINE-IN"){const D=h.productSize;m[D]||(m[D]=0),m[D]+=I.quantity}}const T={Adult:e.adults,Children:e.children,Elder:e.elder};for(const[I,h]of Object.entries(m)){const D=T[I]||0;if(D>0&&h!==D)throw new a({code:"BAD_REQUEST",message:`For dine-in meals, you must select exactly ${D} ${I.toLowerCase()} meal(s) total per session. Currently selected: ${h} for ${I} in session.`})}}for(const c of e.sessionSelections){const m=n.sessions.find(D=>D.id===c.sessionId);if(!m)continue;const T=await r.orderLine.count({where:{sessionId:c.sessionId,product:{productType:"Entry"}}});let I=0;for(const D of c.productSelections)(await r.productType.findUnique({where:{id:D.productTypeId},include:{product:!0}}))?.product.productType==="Entry"&&(I+=D.quantity);const h=m.sessionBalanceCapacity-T;if(I>h)throw new a({code:"BAD_REQUEST",message:`Session "${m.sessionName}" is full or would exceed capacity. Available spots: ${h}, trying to register: ${I}`})}let b=0,v=0;const N=[];for(const c of e.sessionSelections)for(const m of c.productSelections){const T=await r.productType.findUnique({where:{id:m.productTypeId},include:{product:!0}});if(!T)throw new a({code:"NOT_FOUND",message:"Product type not found"});const I=T.productPrice*m.quantity;T.product.productType==="Entry"?b+=I:T.product.productType==="Food"&&(v+=I),N.push({productId:m.productId,productTypeId:m.productTypeId,quantity:m.quantity,sessionId:c.sessionId,price:T.productPrice})}const g=n.sessions.length===d.length;let E=b;g&&b>0&&(E=b*.7);const l=E+v,o=`TXN-${Date.now()}-${U(4).toString("hex").toUpperCase()}`,y=await r.guest.create({data:{memberId:e.memberId,guestName:e.guestName,guestEmail:e.guestEmail,guestPhone:e.guestPhone,guestLocation:e.guestLocation,adults:e.adults,children:e.children,infants:e.infants,elder:e.elder}}),f=await r.orderMaster.create({data:{guestId:y.id,totalCost:l,transactionId:o,orderLines:{create:N.map(c=>({productId:c.productId,productTypeId:c.productTypeId,quantity:c.quantity,sessionId:c.sessionId}))}},include:{orderLines:{include:{product:!0}}}});return{success:!0,transactionId:o,totalCost:l,discountApplied:g&&b>0,discountAmount:g&&b>0?b*.3:0,entryCost:E,foodCost:v,guest:y,order:f}}),ke=i.input(t.object({authToken:t.string(),eventId:t.number(),adults:t.number().min(1),children:t.number().min(0),infants:t.number().min(0),elder:t.number().min(0),sessionSelections:t.array(t.object({sessionId:t.number(),optOutOfFood:t.boolean().default(!1),productSelections:t.array(t.object({productId:t.number(),productTypeId:t.number(),quantity:t.number().min(1)}))}))})).mutation(async({input:e})=>{const{user:s}=await B(e.authToken);if(!s.member)throw new a({code:"BAD_REQUEST",message:"User is not associated with a member account"});const n=s.member,d=await r.event.findUnique({where:{id:e.eventId},include:{sessions:!0}});if(!d)throw new a({code:"NOT_FOUND",message:"Event not found"});const u=e.sessionSelections.map(l=>l.sessionId),p=d.sessions.map(l=>l.id);if(u.filter(l=>!p.includes(l)).length>0)throw new a({code:"BAD_REQUEST",message:"Invalid session selection"});for(const l of e.sessionSelections){const o=d.sessions.find(m=>m.id===l.sessionId);if(!o)continue;const y=await r.orderLine.count({where:{sessionId:l.sessionId,product:{productType:"Entry"}}});let f=0;for(const m of l.productSelections)(await r.productType.findUnique({where:{id:m.productTypeId},include:{product:!0}}))?.product.productType==="Entry"&&(f+=m.quantity);const c=o.sessionBalanceCapacity-y;if(f>c)throw new a({code:"BAD_REQUEST",message:`Session "${o.sessionName}" is full or would exceed capacity. Available spots: ${c}, trying to register: ${f}`})}for(const l of e.sessionSelections)if(l.optOutOfFood){for(const o of l.productSelections)if((await r.productType.findUnique({where:{id:o.productTypeId},include:{product:!0}}))?.product.productType==="Food")throw new a({code:"BAD_REQUEST",message:"Cannot select food products when opted out of food for a session"})}else{const o={};for(const f of l.productSelections){const c=await r.productType.findUnique({where:{id:f.productTypeId},include:{product:!0}});if(!c)throw new a({code:"NOT_FOUND",message:"Product type not found"});if(c.product.productType==="Food"&&c.productSubtype==="DINE-IN"){const m=c.productSize;o[m]||(o[m]=0),o[m]+=f.quantity}}const y={Adult:e.adults,Children:e.children,Elder:e.elder};for(const[f,c]of Object.entries(o)){const m=y[f]||0;if(m>0&&c!==m)throw new a({code:"BAD_REQUEST",message:`For dine-in meals, you must select exactly ${m} ${f.toLowerCase()} meal(s) total per session. Currently selected: ${c} for ${f} in session.`})}}const v=[];let N=0;for(const l of e.sessionSelections)for(const o of l.productSelections){const y=await r.productType.findUnique({where:{id:o.productTypeId},include:{product:!0}});if(!y)throw new a({code:"NOT_FOUND",message:"Product type not found"});const f=y.product.productType==="Entry"?0:y.productPrice;N+=f*o.quantity,v.push({productId:o.productId,productTypeId:o.productTypeId,quantity:o.quantity,sessionId:l.sessionId,price:y.productPrice})}const g=`MBR-${Date.now()}-${U(4).toString("hex").toUpperCase()}`,E=await r.orderMaster.create({data:{memberId:n.id,totalCost:N,transactionId:g,orderLines:{create:v.map(l=>({productId:l.productId,productTypeId:l.productTypeId,quantity:l.quantity,sessionId:l.sessionId}))}},include:{orderLines:{include:{product:!0,productType:!0}}}});return{success:!0,transactionId:g,totalCost:N,member:{...n,familyDetails:{adults:e.adults,children:e.children,infants:e.infants,elder:e.elder}},order:E}}),Me=i.input(t.object({authToken:t.string()})).query(async({input:e})=>(await S(e.authToken),{count:await r.orderMaster.count()})),xe=i.query(async()=>await r.event.findMany({where:{endDate:{gte:new Date}},include:{venue:!0,sessions:{orderBy:{sessionDate:"asc"}}},orderBy:{startDate:"asc"}})),Be=i.query(async()=>await r.member.findMany({select:{id:!0,memberName:!0,memberEmail:!0},orderBy:{memberName:"asc"}})),Fe=i.query(async()=>await r.product.findMany({where:{status:"ACTIVE"},include:{productTypes:{where:{status:"ACTIVE"},orderBy:{productPrice:"asc"}}},orderBy:{createdAt:"desc"}})),Re=i.input(t.object({eventId:t.number().optional()})).query(async({input:e})=>{if(!e.eventId)return[];const s=await r.eventSession.findMany({where:{eventId:e.eventId,sessionDate:{gte:new Date}},include:{event:{select:{id:!0,eventName:!0,startDate:!0,endDate:!0}},productSessionMaps:{include:{product:{include:{productTypes:{where:{status:"ACTIVE"}}}}}}},orderBy:[{sessionDate:"asc"},{startTime:"asc"}]});return await Promise.all(s.map(async d=>{const u=await r.orderLine.count({where:{sessionId:d.id,product:{productType:"Entry"}}}),p=d.sessionBalanceCapacity-u,b=p<=0;return{...d,currentRegistrations:u,availableSpots:p,isFull:b}}))}),O={putObject:async()=>Promise.resolve(),getObject:async()=>Promise.resolve(null),removeObject:async()=>Promise.resolve()},_e=i.input(t.object({authToken:t.string(),fileName:t.string(),fileType:t.string()})).query(async({input:e})=>{await S(e.authToken);const s="expense-receipts",n=Date.now(),d=U(8).toString("hex"),u=e.fileName.split(".").pop()||"",p=`receipt-${n}-${d}.${u}`;try{return await O.bucketExists(s)||await O.makeBucket(s),{presignedUrl:await O.presignedPutObject(s,p,900),objectName:p,bucketName:s}}catch(b){throw new Error(`Failed to generate upload URL: ${b}`)}}),je=i.input(t.object({authToken:t.string(),exportType:t.enum(["expenses","events","sessions","products","registrations"]),eventId:t.number().optional(),startDate:t.string().optional(),endDate:t.string().optional()})).query(async({input:e})=>{const{user:s}=await S(e.authToken);let n=[],d=[];switch(e.exportType){case"expenses":const u={};s.role!=="ADMIN"&&(u.incurredBy=s.memberId),e.eventId&&(u.eventId=e.eventId),e.startDate&&e.endDate&&(u.createdAt={gte:new Date(e.startDate),lte:new Date(e.endDate)});const p=await r.expense.findMany({where:u,include:{member:!0,event:!0},orderBy:{createdAt:"desc"}});d=["Date","Event","Type","Vendor","Amount","Status","Incurred By"],n=p.map(o=>[o.createdAt.toISOString().split("T")[0],o.event.eventName,o.expenseType,o.vendor,o.amount,o.status,o.member.memberName]);break;case"events":if(s.role!=="ADMIN")throw new Error("Unauthorized: Admin access required");const b=await r.event.findMany({include:{venue:!0,sessions:!0,expenses:!0},orderBy:{startDate:"desc"}});d=["Event Name","Start Date","End Date","Venue","Sessions Count","Total Expenses"],n=b.map(o=>[o.eventName,o.startDate.toISOString().split("T")[0],o.endDate.toISOString().split("T")[0],o.venue.venueAddress,o.sessions.length,o.expenses.reduce((y,f)=>f.status==="APPROVED"?y+f.amount:y,0)]);break;case"sessions":const v=await r.eventSession.findMany({where:e.eventId?{eventId:e.eventId}:void 0,include:{event:!0},orderBy:{sessionDate:"desc"}});d=["Session Name","Event","Date","Start Time","End Time","Capacity"],n=v.map(o=>[o.sessionName,o.event.eventName,o.sessionDate.toISOString().split("T")[0],o.startTime,o.endTime,o.sessionBalanceCapacity]);break;case"products":const N=await r.product.findMany({include:{productTypes:!0},orderBy:{createdAt:"desc"}});d=["Product Code","Product Name","Type","Status","Variations Count"],n=N.map(o=>[o.productCode,o.productName,o.productType,o.status,o.productTypes.length]);break;case"registrations":const g=await r.orderMaster.findMany({where:e.eventId?{orderLines:{some:{sessionId:{in:await r.eventSession.findMany({where:{eventId:e.eventId},select:{id:!0}}).then(o=>o.map(y=>y.id))}}}}:void 0,include:{guest:!0,member:!0,orderLines:{include:{product:!0,productType:!0}}},orderBy:{createdAt:"desc"}}),E=[...new Set(g.flatMap(o=>o.orderLines.map(y=>y.sessionId).filter(Boolean)))],l=await r.eventSession.findMany({where:{id:{in:E}},include:{event:!0}});d=["Order Date","Transaction ID","Guest Name","Guest Email","Guest Phone","Guest Location","Adults","Children","Infants","Elders","Total Family Size","Member Name","Member Email","Member Phone","Session Name","Session Date","Session Time","Product Name","Product Type","Product Size","Product Choice","Food Preference","Product Subtype","Quantity","Unit Price","Line Total","Order Total Cost"],n=[];for(const o of g){o.guest||o.member;const y=[o.createdAt.toISOString().split("T")[0],o.transactionId,o.guest?.guestName||o.member?.memberName||"N/A",o.guest?.guestEmail||o.member?.memberEmail||"N/A",o.guest?.guestPhone||o.member?.memberPhone||"N/A",o.guest?.guestLocation||"N/A",o.guest?.adults||o.member?.adults||0,o.guest?.children||o.member?.children||0,o.guest?.infants||o.member?.infants||0,o.guest?.elder||o.member?.elder||0,(o.guest?.adults||o.member?.adults||0)+(o.guest?.children||o.member?.children||0)+(o.guest?.infants||o.member?.infants||0)+(o.guest?.elder||o.member?.elder||0),o.member?.memberName||"N/A",o.member?.memberEmail||"N/A",o.member?.memberPhone||"N/A"],f=o.orderLines.reduce((c,m)=>{const T=m.sessionId||"no-session";return c[T]||(c[T]=[]),c[T].push(m),c},{});for(const[c,m]of Object.entries(f)){const T=l.find(h=>h.id===parseInt(c))||null,I=[T?.sessionName||"No Session",T?.sessionDate?T.sessionDate.toISOString().split("T")[0]:"N/A",T?`${T.startTime} - ${T.endTime}`:"N/A"];for(const h of m){const D=[h.product.productName,h.product.productType,h.productType?.productSize||"N/A",h.productType?.productChoice||"NONE",h.productType?.productPref||"NONE",h.productType?.productSubtype||"NONE",h.quantity,h.productType?.productPrice||0,(h.productType?.productPrice||0)*h.quantity,o.totalCost];n.push([...y,...I,...D])}}}break}return{headers:d,data:n,exportType:e.exportType,timestamp:new Date().toISOString()}}),F=G({login:X,register:Y,getMe:ee,createUser:te,getUsers:se,updateUser:re,deleteUser:oe,createVenue:ne,getVenues:ae,updateVenue:de,deleteVenue:ie,createEvent:ce,getEvents:ue,updateEvent:me,deleteEvent:le,createSession:pe,getSessions:we,updateSession:ye,deleteSession:he,createProduct:Te,getProducts:fe,updateProduct:be,deleteProduct:ge,createProductType:Ie,updateProductType:ve,deleteProductType:Ne,addProductToSession:Ee,removeProductFromSession:De,createExpense:Se,getExpenses:Ce,updateExpenseStatus:Oe,getOrders:Ue,updateOrder:Pe,deleteOrder:Ae,guestRegistration:qe,memberRegistration:ke,getPublicEvents:xe,getPublicMembers:Be,getPublicProducts:Fe,getPublicSessions:Re,getPresignedUrlForUpload:_e,exportToExcel:je,getRegistrationCount:Me});H(F);const Xe=R(e=>{const s=_(e);return s?j({endpoint:"/trpc",req:s,router:F,createContext(){return{}},onError({error:n,path:d}){console.error(`tRPC error on '${d}':`,n)}}):new Response("No request",{status:400})});export{Xe as default};
